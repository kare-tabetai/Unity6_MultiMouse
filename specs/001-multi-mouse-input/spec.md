# 機能仕様: マルチマウス入力マネージャー

**機能ブランチ**: `001-multi-mouse-input`  
**作成日**: 2025-11-13  
**ステータス**: ドラフト  
**入力**: ユーザー記述: "複数のマウス入力を取得するためのマネージャークラス、複数マウス入力動作確認用サンプルシーン、Editor・Build両対応"

## ユーザーシナリオ及びテスト

### ユーザーストーリー 1 - マルチマウスシステムの初期化（優先度: P1）

開発者が Unity6_MultiMouse サンプルを自分のプロジェクトにインポートし、スクリプト内でマルチマウス入力マネージャーを初期化する。複雑なセットアップや設定なしに、接続されたすべてのマウスにアクセスしたい。

**この優先度の理由**: これは基礎機能 - システムを初期化してアクセスする方法がなければ、他のすべての機能は動作しない。他のすべての機能はこの機能に依存している。

**独立テスト**: 開発者が GameObject にマネージャーを追加し、0 個または最小限のパラメータで初期化メソッドを呼び出すことで、すぐに接続されたすべてのマウスからの入力を受け取ることができる。

**受け入れシナリオ**:

1. **前提**: 入力設定のない新しい Unity シーンがある、**実行**: MultiMouseInputManager を初期化する、**期待**: マネージャーが現在接続されているすべてのマウスを検出し、入力受け取り準備が整う
2. **前提**: マネージャーが初期化されている、**実行**: 新しいマウスがシステムに物理的に接続される、**期待**: 新しいマウスが自動検出され、その後のクエリに含まれる
3. **前提**: マウスが切断される、**実行**: 入力がクエリされる、**期待**: 切断されたマウスのデータはもう結果に含まれない

---

### ユーザーストーリー 2 - 個別マウスボタン押下の検出（優先度: P1）

開発者は、物理的にどのマウスが押されたか、どのボタン（左、右、中央）が押されたかを知りたい。そうすれば、複数マウスからの入力を独立して処理できる。

**この優先度の理由**: 核心要件 - ユーザーは異なるマウスからの入力をボタンプレスで区別する必要があり、これが主要なユースケース。

**独立テスト**: 複数のマウスが接続されている状態で、異なるマウスのボタンを押すと、特定のマウスデバイスに相関させることができる区別されたイベントが生成される。Editor のプレイモードとビルドされたアプリケーションの両方でテスト可能。

**受け入れシナリオ**:

1. **前提**: 2 つのマウスが接続されている、**実行**: マウス #1 の左ボタンを押す、**期待**: マウス #1 と左ボタン押下を識別するイベントが発火される
2. **前提**: 2 つのマウスが接続されている、**実行**: マウス #2 の右ボタンを押す、**期待**: マウス #2 と右ボタン押下を識別するイベントが発火される
3. **前提**: 中央ボタンが存在する、**実行**: 中央ボタンが押される、**期待**: 押されたマウスと中央ボタンを識別するイベントが発火される
4. **前提**: ボタンが押された状態が続いている、**実行**: 別のマウスで別のボタンが押される、**期待**: 両方のボタン状態が独立して追跡される

---

### ユーザーストーリー 3 - 個別マウス位置の追跡（優先度: P1）

開発者は接続されたマウスごとの現在スクリーン座標位置をクエリしたい。そうすれば、各マウスのカーソルやUI要素とのインタラクションを独立して処理できる。

**この優先度の理由**: ビジュアルフィードバックとマルチカーソルUI インタラクションに必須 - ユーザーは各マウスのリアルタイム位置データが必要。

**独立テスト**: フレーム内でマウス位置をクエリすることで、接続されたマウスが正確なスクリーン座標を返すことを確認できる。サンプルシーンでの視覚的検証により、複数カーソルが正しい位置に表示される。

**受け入れシナリオ**:

1. **前提**: 2 つのマウスが接続されている、**実行**: マウス位置がクエリされる、**期待**: 各マウスが独立して自分の現在スクリーン位置を返す
2. **前提**: マウス #1 が位置 (100, 200) に移動する、**実行**: 位置がクエリされる、**期待**: マウス #1 の位置は (100, 200) で、マウス #2 の位置は影響されない
3. **前提**: 両方のマウスが同時に移動する、**実行**: 同じフレーム内で位置がクエリされる、**期待**: 両方の位置が互いに独立した現在の移動を反映する

---

### ユーザーストーリー 4 - 個別マウス移動デルタの追跡（優先度: P1）

開発者は各マウスが現在フレーム内で、または前フレームからどれだけ移動したかをクエリしたい。そうすれば、マウスベースのカメラ制御やエイムメカニクスを実装でき、各マウスで独立して動作させられる。

**この優先度の理由**: インタラクティブアプリケーションに必須 - ユーザーはスムーズでレスポンシブな入力（アクションゲームは低遅延の移動追跡が必要）のためにデルタ移動が必要。

**独立テスト**: フレーム内で移動デルタをクエリすることで、接続されたマウスが移動相対値（deltaX、deltaY）を返すことを確認できる。サンプルシーンでの視覚的検証により、マウスごとの移動量と方向が表示される。

**受け入れシナリオ**:

1. **前提**: 2 つのマウスが接続されている、**実行**: フレーム内で移動デルタがクエリされる、**期待**: 各マウスが独立して移動ベクトル（deltaX、deltaY）を返す
2. **前提**: マウス #1 が 10 ピクセル右に移動し、マウス #2 が 5 ピクセル下に移動する、**実行**: デルタがクエリされる、**期待**: マウス #1 デルタは (10, 0) で、マウス #2 デルタは (0, 5)
3. **前提**: マウスが フレーム内で移動しない、**実行**: デルタがクエリされる、**期待**: デルタは (0, 0)

---

### ユーザーストーリー 5 - サンプルシーンでマルチマウスアクティビティの可視化（優先度: P2）

開発者は、複数マウス入力を動作中に見ることで、明確でインタラクティブなビジュアル表示を求めている。接続されたすべてのマウスのボタン状態、位置、動きを表示する。これはドキュメント化とユーザーのシステム検証ツールの両方として機能する。

**この優先度の理由**: 高価値の参考実装 - 正しい使用パターンを示し、ユーザーがシステムが動作していることを検証するのに役立つ。ユーザー自身のアプリケーションへの統合を必要としずに独立してテスト可能。

**独立テスト**: Unity Editor またはビルドされたアプリケーションでサンプルシーンを開き、複数のマウスを接続し、シーンとインタラクションする。すべてのマウスアクティビティ（ボタン、位置、動き）がリアルタイムでシーンに表示される。

**受け入れシナリオ**:

1. **前提**: サンプルシーンが実行中、**実行**: 任意のマウスでボタンが押される、**期待**: UI またはビジュアル要素がどのマウスのどのボタンが押されたかを表示する
2. **前提**: サンプルシーンが実行中、**実行**: マウスが移動する、**期待**: ビジュアルカーソルまたはインジケータが各マウスの位置を独立して追跡する
3. **前提**: サンプルシーンが実行中、**実行**: マウスが移動する、**期待**: 移動量または方向インジケータが更新され、デルタ移動を表示する
4. **前提**: サンプルシーンが Editor のプレイモードで実行中、**実行**: マウスが移動・クリックされる、**期待**: 動作がビルドされたアプリケーションでの実行と同じ

---

### エッジケース

- 10 個以上のマウスが同時に接続されている場合はどうなるか？
- 複数マウスでの高速ボタンプレス/リリースシーケンスについて、システムはどう処理するか？
- アプリケーション実行中にマウスが切断される場合はどうなるか？
- マウスが接続されていないシステムではどうなるか？（空のデータをグレースフルに返すべき）

## 要件

### 機能要件

- **FR-001**: システムは物理/仮想デバイスドライバ経由で接続されたすべての Windows マウスを検出しなければならない
- **FR-002**: システムは各マウスをデバイス ID または同様の永続的な識別子で一意に識別しなければならない
- **FR-003**: システムは各マウスについて左、右、中央マウスボタンの状態（押下、保持、リリース）を独立して提供しなければならない
- **FR-004**: システムは接続されたマウスごとに現在のスクリーン座標（ピクセル）位置を提供しなければならない
- **FR-005**: システムは各マウスのムーブメントデルタ（位置の変化）をフレーム単位で最小遅延で提供しなければならない
- **FR-006**: システムはマネージャーを C# クラスとして実装し、スタティックまたはシングルトンパターン経由でアクセスでき、外部ライブラリに依存してはいけない
- **FR-007**: システムは Unity Editor のプレイモードとビルドされた Windows アプリケーションで同じように動作しなければならない
- **FR-008**: システムは Windows API（user32.dll など）への C# DllImport 呼び出しのみを使用し、C++ ラッパーや COM interop は使用してはいけない
- **FR-009**: システムはサンプルシーンを提供し、接続されたすべてのマウスからの入力を可視化する（ボタンプレス、カーソル位置、移動）
- **FR-010**: サンプルシーンは新規 Unity 6 エディタから追加のビルド手順または設定なしで起動可能でなければならない

### 非機能要件

- **NFR-001**: 入力遅延は無視できるレベル（60 FPS で < 1 フレーム）でなければならない（アクションゲーム対応用）
- **NFR-002**: Unity 6 標準モジュール以外の外部アセット、プラグイン、またはライブラリはない
- **NFR-003**: コードは初学者が理解できるシンプルなものでなければならない - 高度な設計パターン、正当化がない抽象化層は不可
- **NFR-004**: API サーフェスは最小限でなければならない - マウスをクエリするメインメソッドは 0～1 個のパラメータが必須
- **NFR-005**: すべての DllImport 宣言は Windows API ドキュメント参照とパラメータ説明を含まねばならない
- **NFR-006**: システムは 4 個以上のマウスを同時にサポートし、パフォーマンス低下なく動作しなければならない

### キーエンティティ

- **マウスデバイス**: 一意の ID、現在位置、ボタン状態、ムーブメントデルタを持つ、接続されたマウスを表す
- **マウス入力状態**: 特定時点での単一マウスの状態スナップショット（位置、ボタン、デルタ）
- **入力マネージャー**: 接続されたすべてのマウスからの入力を集約し、クエリメソッドを公開する中央マネージャークラス

## 成功基準

### 測定可能なアウトカム

- **SC-001**: 4 個のマウスが同時に検出・追跡され、データ損失またはクロスコンタミネーションなしでサンプルシーン内で動作する
- **SC-002**: ボタンプレスイベントはゼロフレームディレイで配信される（入力が発生した同じフレーム内）
- **SC-003**: ムーブメントデルタ値は物理マウス移動とクエリ可能なデータ間で < 1ms 遅延を示す
- **SC-004**: サンプルシーンは 4 個のマウスが接続されている標準 Windows 開発マシンで 60+ FPS で実行される
- **SC-005**: 完全な統合例（コード + サンプルシーン）が提供され、開発者がコピー/ペースト直後に使用できる
- **SC-006**: 初回ユーザーがプロジェクトを開いてから 5 分以内にマルチマウス機能を理解・検証できる

